<?php

declare(strict_types=1);

/*
 * This file has been auto generated by Jane,
 *
 * Do no edit it directly.
 */

namespace Docker\OpenAPI;

class Client extends \Docker\OpenAPI\Runtime\Client\Client
{
    /**
     * Returns a list of containers. For details on the format, see the.
     *
     * @param array $queryParameters {
     *
     *     @var bool $all Return all containers. By default, only running containers are shown.

     *     @var int $limit Return this number of most recently created containers, including
     *     @var bool $size Return the size of container as fields `SizeRw` and `SizeRootFs`.

     *     @var string $filters Filters to process on the container list, encoded as JSON (a
     * }
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\OpenAPI\Exception\ContainerListBadRequestException
     * @throws \Docker\OpenAPI\Exception\ContainerListInternalServerErrorException
     *
     * @return \Docker\OpenAPI\Model\ContainerSummaryItem[]|\Psr\Http\Message\ResponseInterface|null
     */
    public function containerList(array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new \Docker\OpenAPI\Endpoint\ContainerList($queryParameters), $fetch);
    }

    /**
     * @param \Docker\OpenAPI\Model\ContainersCreatePostBody $body            Container to create
     * @param array                                          $queryParameters {
     *
     *     @var string $name Assign the specified name to the container. Must match
    `/?[a-zA-Z0-9][a-zA-Z0-9_.-]+`.

     * }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\OpenAPI\Exception\ContainerCreateBadRequestException
     * @throws \Docker\OpenAPI\Exception\ContainerCreateNotFoundException
     * @throws \Docker\OpenAPI\Exception\ContainerCreateConflictException
     * @throws \Docker\OpenAPI\Exception\ContainerCreateInternalServerErrorException
     *
     * @return \Docker\OpenAPI\Model\ContainersCreatePostResponse201|\Psr\Http\Message\ResponseInterface|null
     */
    public function containerCreate(\Docker\OpenAPI\Model\ContainersCreatePostBody $body, array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new \Docker\OpenAPI\Endpoint\ContainerCreate($body, $queryParameters), $fetch);
    }

    /**
     * Return low-level information about a container.
     *
     * @param string $id              ID or name of the container
     * @param array  $queryParameters {
     *
     *     @var bool $size Return the size of container as fields `SizeRw` and `SizeRootFs`
     * }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\OpenAPI\Exception\ContainerInspectNotFoundException
     * @throws \Docker\OpenAPI\Exception\ContainerInspectInternalServerErrorException
     *
     * @return \Docker\OpenAPI\Model\ContainersIdJsonGetResponse200|\Psr\Http\Message\ResponseInterface|null
     */
    public function containerInspect(string $id, array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new \Docker\OpenAPI\Endpoint\ContainerInspect($id, $queryParameters), $fetch);
    }

    /**
     * On Unix systems, this is done by running the `ps` command. This endpoint.
     *
     * @param string $id              ID or name of the container
     * @param array  $queryParameters {
     *
     *     @var string $ps_args The arguments to pass to `ps`. For example, `aux`
     * }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\OpenAPI\Exception\ContainerTopNotFoundException
     * @throws \Docker\OpenAPI\Exception\ContainerTopInternalServerErrorException
     *
     * @return \Docker\OpenAPI\Model\ContainersIdTopGetResponse200|\Psr\Http\Message\ResponseInterface|null
     */
    public function containerTop(string $id, array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new \Docker\OpenAPI\Endpoint\ContainerTop($id, $queryParameters), $fetch);
    }

    /**
     * Get `stdout` and `stderr` logs from a container.

     *
     * @param string $id              ID or name of the container
     * @param array  $queryParameters {
     *
     *     @var bool $follow keep connection after returning logs
     *     @var bool $stdout Return logs from `stdout`
     *     @var bool $stderr Return logs from `stderr`
     *     @var int $since Only return logs since this time, as a UNIX timestamp
     *     @var int $until Only return logs before this time, as a UNIX timestamp
     *     @var bool $timestamps Add timestamps to every log line
     *     @var string $tail Only return this number of log lines from the end of the logs.
    Specify as an integer or `all` to output all log lines.

     * }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\OpenAPI\Exception\ContainerLogsNotFoundException
     * @throws \Docker\OpenAPI\Exception\ContainerLogsInternalServerErrorException
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function containerLogs(string $id, array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new \Docker\OpenAPI\Endpoint\ContainerLogs($id, $queryParameters), $fetch);
    }

    /**
     * Returns which files in a container's filesystem have been added, deleted,.
     *
     * @param string $id    ID or name of the container
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\OpenAPI\Exception\ContainerChangesNotFoundException
     * @throws \Docker\OpenAPI\Exception\ContainerChangesInternalServerErrorException
     *
     * @return \Docker\OpenAPI\Model\ContainersIdChangesGetResponse200Item[]|\Psr\Http\Message\ResponseInterface|null
     */
    public function containerChanges(string $id, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new \Docker\OpenAPI\Endpoint\ContainerChanges($id), $fetch);
    }

    /**
     * Export the contents of a container as a tarball.
     *
     * @param string $id    ID or name of the container
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\OpenAPI\Exception\ContainerExportNotFoundException
     * @throws \Docker\OpenAPI\Exception\ContainerExportInternalServerErrorException
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function containerExport(string $id, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new \Docker\OpenAPI\Endpoint\ContainerExport($id), $fetch);
    }

    /**
     * This endpoint returns a live stream of a container’s resource usage.
    statistics.

    The `precpu_stats` is the CPU statistic of the *previous* read, and is
    used to calculate the CPU usage percentage. It is not an exact copy
    of the `cpu_stats` field.

    If either `precpu_stats.online_cpus` or `cpu_stats.online_cpus` is
    nil then for compatibility with older daemons the length of the
    corresponding `cpu_usage.percpu_usage` array should be used.

    To calculate the values shown by the `stats` command of the docker cli tool
    the following formulas can be used:
     * used_memory = `memory_stats.usage - memory_stats.stats.cache`
     * available_memory = `memory_stats.limit`
     * Memory usage % = `(used_memory / available_memory) * 100.0`
     * cpu_delta = `cpu_stats.cpu_usage.total_usage - precpu_stats.cpu_usage.total_usage`
     * system_cpu_delta = `cpu_stats.system_cpu_usage - precpu_stats.system_cpu_usage`
     * number_cpus = `lenght(cpu_stats.cpu_usage.percpu_usage)` or `cpu_stats.online_cpus`
     * CPU usage % = `(cpu_delta / system_cpu_delta) * number_cpus * 100.0`

     *
     * @param string $id              ID or name of the container
     * @param array  $queryParameters {
     *
     *     @var bool $stream Stream the output. If false, the stats will be output once and then
    it will disconnect.

     * }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\OpenAPI\Exception\ContainerStatsNotFoundException
     * @throws \Docker\OpenAPI\Exception\ContainerStatsInternalServerErrorException
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function containerStats(string $id, array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new \Docker\OpenAPI\Endpoint\ContainerStats($id, $queryParameters), $fetch);
    }

    /**
     * Resize the TTY for a container.
     *
     * @param string $id              ID or name of the container
     * @param array  $queryParameters {
     *
     *     @var int $h Height of the TTY session in characters
     *     @var int $w Width of the TTY session in characters
     * }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\OpenAPI\Exception\ContainerResizeNotFoundException
     * @throws \Docker\OpenAPI\Exception\ContainerResizeInternalServerErrorException
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function containerResize(string $id, array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new \Docker\OpenAPI\Endpoint\ContainerResize($id, $queryParameters), $fetch);
    }

    /**
     * @param string $id              ID or name of the container
     * @param array  $queryParameters {
     *
     *     @var string $detachKeys Override the key sequence for detaching a container. Format is a
     * }
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\OpenAPI\Exception\ContainerStartNotFoundException
     * @throws \Docker\OpenAPI\Exception\ContainerStartInternalServerErrorException
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function containerStart(string $id, array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new \Docker\OpenAPI\Endpoint\ContainerStart($id, $queryParameters), $fetch);
    }

    /**
     * @param string $id              ID or name of the container
     * @param array  $queryParameters {
     *
     *     @var int $t Number of seconds to wait before killing the container
     * }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\OpenAPI\Exception\ContainerStopNotFoundException
     * @throws \Docker\OpenAPI\Exception\ContainerStopInternalServerErrorException
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function containerStop(string $id, array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new \Docker\OpenAPI\Endpoint\ContainerStop($id, $queryParameters), $fetch);
    }

    /**
     * @param string $id              ID or name of the container
     * @param array  $queryParameters {
     *
     *     @var int $t Number of seconds to wait before killing the container
     * }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\OpenAPI\Exception\ContainerRestartNotFoundException
     * @throws \Docker\OpenAPI\Exception\ContainerRestartInternalServerErrorException
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function containerRestart(string $id, array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new \Docker\OpenAPI\Endpoint\ContainerRestart($id, $queryParameters), $fetch);
    }

    /**
     * Send a POSIX signal to a container, defaulting to killing to the.
     *
     * @param string $id              ID or name of the container
     * @param array  $queryParameters {
     *
     *     @var string $signal Signal to send to the container as an integer or string (e.g. `SIGINT`)
     * }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\OpenAPI\Exception\ContainerKillNotFoundException
     * @throws \Docker\OpenAPI\Exception\ContainerKillConflictException
     * @throws \Docker\OpenAPI\Exception\ContainerKillInternalServerErrorException
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function containerKill(string $id, array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new \Docker\OpenAPI\Endpoint\ContainerKill($id, $queryParameters), $fetch);
    }

    /**
     * Change various configuration options of a container without having to.
     *
     * @param string $id    ID or name of the container
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\OpenAPI\Exception\ContainerUpdateNotFoundException
     * @throws \Docker\OpenAPI\Exception\ContainerUpdateInternalServerErrorException
     *
     * @return \Docker\OpenAPI\Model\ContainersIdUpdatePostResponse200|\Psr\Http\Message\ResponseInterface|null
     */
    public function containerUpdate(string $id, \Docker\OpenAPI\Model\ContainersIdUpdatePostBody $update, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new \Docker\OpenAPI\Endpoint\ContainerUpdate($id, $update), $fetch);
    }

    /**
     * @param string $id              ID or name of the container
     * @param array  $queryParameters {
     *
     *     @var string $name New name for the container
     * }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\OpenAPI\Exception\ContainerRenameNotFoundException
     * @throws \Docker\OpenAPI\Exception\ContainerRenameConflictException
     * @throws \Docker\OpenAPI\Exception\ContainerRenameInternalServerErrorException
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function containerRename(string $id, array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new \Docker\OpenAPI\Endpoint\ContainerRename($id, $queryParameters), $fetch);
    }

    /**
     * Use the freezer cgroup to suspend all processes in a container.

     *
     * @param string $id    ID or name of the container
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\OpenAPI\Exception\ContainerPauseNotFoundException
     * @throws \Docker\OpenAPI\Exception\ContainerPauseInternalServerErrorException
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function containerPause(string $id, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new \Docker\OpenAPI\Endpoint\ContainerPause($id), $fetch);
    }

    /**
     * Resume a container which has been paused.
     *
     * @param string $id    ID or name of the container
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\OpenAPI\Exception\ContainerUnpauseNotFoundException
     * @throws \Docker\OpenAPI\Exception\ContainerUnpauseInternalServerErrorException
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function containerUnpause(string $id, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new \Docker\OpenAPI\Endpoint\ContainerUnpause($id), $fetch);
    }

    /**
     * Attach to a container to read its output or send it input. You can attach.
     *
     * @param string $id              ID or name of the container
     * @param array  $queryParameters {
     *
     *     @var string $detachKeys Override the key sequence for detaching a container.Format is a single
     *     @var bool $logs Replay previous logs from the container.

     *     @var bool $stream Stream attached streams from the time the request was made onwards.

     *     @var bool $stdin Attach to `stdin`
     *     @var bool $stdout Attach to `stdout`
     *     @var bool $stderr Attach to `stderr`
     * }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\OpenAPI\Exception\ContainerAttachBadRequestException
     * @throws \Docker\OpenAPI\Exception\ContainerAttachNotFoundException
     * @throws \Docker\OpenAPI\Exception\ContainerAttachInternalServerErrorException
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function containerAttach(string $id, array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new \Docker\OpenAPI\Endpoint\ContainerAttach($id, $queryParameters), $fetch);
    }

    /**
     * @param string $id              ID or name of the container
     * @param array  $queryParameters {
     *
     *     @var string $detachKeys Override the key sequence for detaching a container.Format is a single
     *     @var bool $logs Return logs
     *     @var bool $stream Return stream
     *     @var bool $stdin Attach to `stdin`
     *     @var bool $stdout Attach to `stdout`
     *     @var bool $stderr Attach to `stderr`
     * }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\OpenAPI\Exception\ContainerAttachWebsocketBadRequestException
     * @throws \Docker\OpenAPI\Exception\ContainerAttachWebsocketNotFoundException
     * @throws \Docker\OpenAPI\Exception\ContainerAttachWebsocketInternalServerErrorException
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function containerAttachWebsocket(string $id, array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new \Docker\OpenAPI\Endpoint\ContainerAttachWebsocket($id, $queryParameters), $fetch);
    }

    /**
     * Block until a container stops, then returns the exit code.
     *
     * @param string $id              ID or name of the container
     * @param array  $queryParameters {
     *
     *     @var string $condition Wait until a container state reaches the given condition, either
    'not-running' (default), 'next-exit', or 'removed'.

     * }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\OpenAPI\Exception\ContainerWaitNotFoundException
     * @throws \Docker\OpenAPI\Exception\ContainerWaitInternalServerErrorException
     *
     * @return \Docker\OpenAPI\Model\ContainersIdWaitPostResponse200|\Psr\Http\Message\ResponseInterface|null
     */
    public function containerWait(string $id, array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new \Docker\OpenAPI\Endpoint\ContainerWait($id, $queryParameters), $fetch);
    }

    /**
     * @param string $id              ID or name of the container
     * @param array  $queryParameters {
     *
     *     @var bool $v remove the volumes associated with the container
     *     @var bool $force if the container is running, kill it before removing it
     *     @var bool $link Remove the specified link associated with the container.
     * }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\OpenAPI\Exception\ContainerDeleteBadRequestException
     * @throws \Docker\OpenAPI\Exception\ContainerDeleteNotFoundException
     * @throws \Docker\OpenAPI\Exception\ContainerDeleteConflictException
     * @throws \Docker\OpenAPI\Exception\ContainerDeleteInternalServerErrorException
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function containerDelete(string $id, array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new \Docker\OpenAPI\Endpoint\ContainerDelete($id, $queryParameters), $fetch);
    }

    /**
     * Get a tar archive of a resource in the filesystem of container id.
     *
     * @param string $id              ID or name of the container
     * @param array  $queryParameters {
     *
     *     @var string $path Resource in the container’s filesystem to archive.
     * }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\OpenAPI\Exception\ContainerArchiveBadRequestException
     * @throws \Docker\OpenAPI\Exception\ContainerArchiveNotFoundException
     * @throws \Docker\OpenAPI\Exception\ContainerArchiveInternalServerErrorException
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function containerArchive(string $id, array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new \Docker\OpenAPI\Endpoint\ContainerArchive($id, $queryParameters), $fetch);
    }

    /**
     * A response header `X-Docker-Container-Path-Stat` is returned, containing.
     *
     * @param string $id              ID or name of the container
     * @param array  $queryParameters {
     *
     *     @var string $path Resource in the container’s filesystem to archive.
     * }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\OpenAPI\Exception\ContainerArchiveInfoBadRequestException
     * @throws \Docker\OpenAPI\Exception\ContainerArchiveInfoNotFoundException
     * @throws \Docker\OpenAPI\Exception\ContainerArchiveInfoInternalServerErrorException
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function containerArchiveInfo(string $id, array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new \Docker\OpenAPI\Endpoint\ContainerArchiveInfo($id, $queryParameters), $fetch);
    }

    /**
     * Upload a tar archive to be extracted to a path in the filesystem of container id.
     *
     * @param string                                            $id              ID or name of the container
     * @param string|resource|\Psr\Http\Message\StreamInterface $inputStream     The input stream must be a tar archive compressed with one of the
     * @param array                                             $queryParameters {
     *
     *     @var string $path path to a directory in the container to extract the archive’s contents into
     *     @var string $noOverwriteDirNonDir If `1`, `true`, or `True` then it will be an error if unpacking the
     *     @var string $copyUIDGID If `1`, `true`, then it will copy UID/GID maps to the dest file or
    dir

     * }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\OpenAPI\Exception\PutContainerArchiveBadRequestException
     * @throws \Docker\OpenAPI\Exception\PutContainerArchiveForbiddenException
     * @throws \Docker\OpenAPI\Exception\PutContainerArchiveNotFoundException
     * @throws \Docker\OpenAPI\Exception\PutContainerArchiveInternalServerErrorException
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function putContainerArchive(string $id, $inputStream, array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new \Docker\OpenAPI\Endpoint\PutContainerArchive($id, $inputStream, $queryParameters), $fetch);
    }

    /**
     * @param array $queryParameters {
     *
     *     @var string $filters Filters to process on the prune list, encoded as JSON (a `map[string][]string`).

     * }
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\OpenAPI\Exception\ContainerPruneInternalServerErrorException
     *
     * @return \Docker\OpenAPI\Model\ContainersPrunePostResponse200|\Psr\Http\Message\ResponseInterface|null
     */
    public function containerPrune(array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new \Docker\OpenAPI\Endpoint\ContainerPrune($queryParameters), $fetch);
    }

    /**
     * Returns a list of images on the server. Note that it uses a different, smaller representation of an image than inspecting a single image.
     *
     * @param array $queryParameters {
     *
     *     @var bool $all Show all images. Only images from a final layer (no children) are shown by default.
     *     @var string $filters A JSON encoded value of the filters (a `map[string][]string`) to
     *     @var bool $digests Show digest information as a `RepoDigests` field on each image.
     * }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\OpenAPI\Exception\ImageListInternalServerErrorException
     *
     * @return \Docker\OpenAPI\Model\ImageSummary[]|\Psr\Http\Message\ResponseInterface|null
     */
    public function imageList(array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new \Docker\OpenAPI\Endpoint\ImageList($queryParameters), $fetch);
    }

    /**
     * Build an image from a tar archive with a `Dockerfile` in it.

     *
     * @param string|resource|\Psr\Http\Message\StreamInterface $inputStream     a tar archive compressed with one of the following algorithms: identity (no compression), gzip, bzip2, xz
     * @param array                                             $queryParameters {
     *
     *     @var string $dockerfile Path within the build context to the `Dockerfile`. This is ignored if `remote` is specified and points to an external `Dockerfile`.
     *     @var string $t A name and optional tag to apply to the image in the `name:tag` format. If you omit the tag the default `latest` value is assumed. You can provide several `t` parameters.
     *     @var string $extrahosts Extra hosts to add to /etc/hosts
     *     @var string $remote A Git repository URI or HTTP/HTTPS context URI. If the URI points to a single text file, the file’s contents are placed into a file called `Dockerfile` and the image is built from that file. If the URI points to a tarball, the file is downloaded by the daemon and the contents therein used as the context for the build. If the URI points to a tarball and the `dockerfile` parameter is also specified, there must be a file with the corresponding path inside the tarball.
     *     @var bool $q suppress verbose build output
     *     @var bool $nocache do not use the cache when building the image
     *     @var string $cachefrom JSON array of images used for build cache resolution
     *     @var string $pull attempt to pull the image even if an older image exists locally
     *     @var bool $rm remove intermediate containers after a successful build
     *     @var bool $forcerm always remove intermediate containers, even upon failure
     *     @var int $memory set memory limit for build
     *     @var int $memswap Total memory (memory + swap). Set as `-1` to disable swap.
     *     @var int $cpushares CPU shares (relative weight)
     *     @var string $cpusetcpus CPUs in which to allow execution (e.g., `0-3`, `0,1`).
     *     @var int $cpuperiod the length of a CPU period in microseconds
     *     @var int $cpuquota microseconds of CPU time that the container can get in a CPU period
     *     @var string $buildargs JSON map of string pairs for build-time variables. Users pass these values at build-time. Docker uses the buildargs as the environment context for commands run via the `Dockerfile` RUN instruction, or for variable expansion in other `Dockerfile` instructions. This is not meant for passing secret values.

     *     @var int $shmsize Size of `/dev/shm` in bytes. The size must be greater than 0. If omitted the system uses 64MB.
     *     @var bool $squash Squash the resulting images layers into a single layer. *(Experimental release only.)*
     *     @var string $labels arbitrary key/value labels to set on the image, as a JSON map of string pairs
     *     @var string $networkmode Sets the networking mode for the run commands during build. Supported
     *     @var string $platform Platform in the format os[/arch[/variant]]
     *     @var string $target Target build stage
     *     @var string $outputs BuildKit output configuration
     * }
     *
     * @param array $headerParameters {
     *
     *     @var string $Content-type
     *     @var string $X-Registry-Config This is a base64-encoded JSON object with auth configurations for multiple registries that a build may refer to.

     * }
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\OpenAPI\Exception\ImageBuildBadRequestException
     * @throws \Docker\OpenAPI\Exception\ImageBuildInternalServerErrorException
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function imageBuild($inputStream, array $queryParameters = [], array $headerParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new \Docker\OpenAPI\Endpoint\ImageBuild($inputStream, $queryParameters, $headerParameters), $fetch);
    }

    /**
     * @param array $queryParameters {
     *
     *     @var int $keep-storage Amount of disk space in bytes to keep for cache
     *     @var bool $all Remove all types of build cache
     *     @var string $filters A JSON encoded value of the filters (a `map[string][]string`) to
     * }
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\OpenAPI\Exception\BuildPruneInternalServerErrorException
     *
     * @return \Docker\OpenAPI\Model\BuildPrunePostResponse200|\Psr\Http\Message\ResponseInterface|null
     */
    public function buildPrune(array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new \Docker\OpenAPI\Endpoint\BuildPrune($queryParameters), $fetch);
    }

    /**
     * Create an image by either pulling it from a registry or importing it.
     *
     * @param string $inputImage      Image content if the value `-` has been specified in fromSrc query parameter
     * @param array  $queryParameters {
     *
     *     @var string $fromImage Name of the image to pull. The name may include a tag or digest. This parameter may only be used when pulling an image. The pull is cancelled if the HTTP connection is closed.
     *     @var string $fromSrc Source to import. The value may be a URL from which the image can be retrieved or `-` to read the image from the request body. This parameter may only be used when importing an image.
     *     @var string $repo Repository name given to an image when it is imported. The repo may include a tag. This parameter may only be used when importing an image.
     *     @var string $tag Tag or digest. If empty when pulling an image, this causes all tags for the given image to be pulled.
     *     @var string $message set commit message for imported image
     *     @var string $platform Platform in the format os[/arch[/variant]]
     * }
     *
     * @param array $headerParameters {
     *
     *     @var string $X-Registry-Auth A base64url-encoded auth configuration.

     * }
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\OpenAPI\Exception\ImageCreateNotFoundException
     * @throws \Docker\OpenAPI\Exception\ImageCreateInternalServerErrorException
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function imageCreate(string $inputImage, array $queryParameters = [], array $headerParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new \Docker\OpenAPI\Endpoint\ImageCreate($inputImage, $queryParameters, $headerParameters), $fetch);
    }

    /**
     * Return low-level information about an image.
     *
     * @param string $name  Image name or id
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\OpenAPI\Exception\ImageInspectNotFoundException
     * @throws \Docker\OpenAPI\Exception\ImageInspectInternalServerErrorException
     *
     * @return \Docker\OpenAPI\Model\Image|\Psr\Http\Message\ResponseInterface|null
     */
    public function imageInspect(string $name, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new \Docker\OpenAPI\Endpoint\ImageInspect($name), $fetch);
    }

    /**
     * Return parent layers of an image.
     *
     * @param string $name  Image name or ID
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\OpenAPI\Exception\ImageHistoryNotFoundException
     * @throws \Docker\OpenAPI\Exception\ImageHistoryInternalServerErrorException
     *
     * @return \Docker\OpenAPI\Model\ImagesNameHistoryGetResponse200Item[]|\Psr\Http\Message\ResponseInterface|null
     */
    public function imageHistory(string $name, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new \Docker\OpenAPI\Endpoint\ImageHistory($name), $fetch);
    }

    /**
     * Push an image to a registry.

     *
     * @param string $name            image name or ID
     * @param array  $queryParameters {
     *
     *     @var string $tag The tag to associate with the image on the registry.
     * }
     *
     * @param array $headerParameters {
     *
     *     @var string $X-Registry-Auth A base64url-encoded auth configuration.

     * }
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\OpenAPI\Exception\ImagePushNotFoundException
     * @throws \Docker\OpenAPI\Exception\ImagePushInternalServerErrorException
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function imagePush(string $name, array $queryParameters = [], array $headerParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new \Docker\OpenAPI\Endpoint\ImagePush($name, $queryParameters, $headerParameters), $fetch);
    }

    /**
     * Tag an image so that it becomes part of a repository.
     *
     * @param string $name            image name or ID to tag
     * @param array  $queryParameters {
     *
     *     @var string $repo The repository to tag in. For example, `someuser/someimage`.
     *     @var string $tag The name of the new tag.
     * }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\OpenAPI\Exception\ImageTagBadRequestException
     * @throws \Docker\OpenAPI\Exception\ImageTagNotFoundException
     * @throws \Docker\OpenAPI\Exception\ImageTagConflictException
     * @throws \Docker\OpenAPI\Exception\ImageTagInternalServerErrorException
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function imageTag(string $name, array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new \Docker\OpenAPI\Endpoint\ImageTag($name, $queryParameters), $fetch);
    }

    /**
     * Remove an image, along with any untagged parent images that were.
     *
     * @param string $name            Image name or ID
     * @param array  $queryParameters {
     *
     *     @var bool $force Remove the image even if it is being used by stopped containers or has other tags
     *     @var bool $noprune Do not delete untagged parent images
     * }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\OpenAPI\Exception\ImageDeleteNotFoundException
     * @throws \Docker\OpenAPI\Exception\ImageDeleteConflictException
     * @throws \Docker\OpenAPI\Exception\ImageDeleteInternalServerErrorException
     *
     * @return \Docker\OpenAPI\Model\ImageDeleteResponseItem[]|\Psr\Http\Message\ResponseInterface|null
     */
    public function imageDelete(string $name, array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new \Docker\OpenAPI\Endpoint\ImageDelete($name, $queryParameters), $fetch);
    }

    /**
     * Search for an image on Docker Hub.
     *
     * @param array $queryParameters {
     *
     *     @var string $term Term to search
     *     @var int $limit Maximum number of results to return
     *     @var string $filters A JSON encoded value of the filters (a `map[string][]string`) to process on the images list. Available filters:

     * }
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\OpenAPI\Exception\ImageSearchInternalServerErrorException
     *
     * @return \Docker\OpenAPI\Model\ImagesSearchGetResponse200Item[]|\Psr\Http\Message\ResponseInterface|null
     */
    public function imageSearch(array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new \Docker\OpenAPI\Endpoint\ImageSearch($queryParameters), $fetch);
    }

    /**
     * @param array $queryParameters {
     *
     *     @var string $filters Filters to process on the prune list, encoded as JSON (a `map[string][]string`). Available filters:

    - `dangling=<boolean>` When set to `true` (or `1`), prune only
      unused *and* untagged images. When set to `false`
     * }
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\OpenAPI\Exception\ImagePruneInternalServerErrorException
     *
     * @return \Docker\OpenAPI\Model\ImagesPrunePostResponse200|\Psr\Http\Message\ResponseInterface|null
     */
    public function imagePrune(array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new \Docker\OpenAPI\Endpoint\ImagePrune($queryParameters), $fetch);
    }

    /**
     * Validate credentials for a registry and, if available, get an identity.
     *
     * @param \Docker\OpenAPI\Model\AuthConfig $authConfig Authentication to check
     * @param string                           $fetch      Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\OpenAPI\Exception\SystemAuthInternalServerErrorException
     *
     * @return \Docker\OpenAPI\Model\AuthPostResponse200|\Psr\Http\Message\ResponseInterface|null
     */
    public function systemAuth(\Docker\OpenAPI\Model\AuthConfig $authConfig, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new \Docker\OpenAPI\Endpoint\SystemAuth($authConfig), $fetch);
    }

    /**
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\OpenAPI\Exception\SystemInfoInternalServerErrorException
     *
     * @return \Docker\OpenAPI\Model\SystemInfo|\Psr\Http\Message\ResponseInterface|null
     */
    public function systemInfo(string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new \Docker\OpenAPI\Endpoint\SystemInfo(), $fetch);
    }

    /**
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\OpenAPI\Exception\SystemVersionInternalServerErrorException
     *
     * @return \Docker\OpenAPI\Model\SystemVersion|\Psr\Http\Message\ResponseInterface|null
     */
    public function systemVersion(string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new \Docker\OpenAPI\Endpoint\SystemVersion(), $fetch);
    }

    /**
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\OpenAPI\Exception\SystemPingInternalServerErrorException
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function systemPing(string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new \Docker\OpenAPI\Endpoint\SystemPing(), $fetch);
    }

    /**
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\OpenAPI\Exception\SystemPingHeadInternalServerErrorException
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function systemPingHead(string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new \Docker\OpenAPI\Endpoint\SystemPingHead(), $fetch);
    }

    /**
     * @param \Docker\OpenAPI\Model\ContainerConfig $containerConfig The container configuration
     * @param array                                 $queryParameters {
     *
     *     @var string $container The ID or name of the container to commit
     *     @var string $repo Repository name for the created image
     *     @var string $tag Tag name for the create image
     *     @var string $comment Commit message
     *     @var string $author Author of the image (e.g., `John Hannibal Smith <hannibal@a-team.com>`)
     *     @var bool $pause Whether to pause the container before committing
     *     @var string $changes `Dockerfile` instructions to apply while committing
     * }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\OpenAPI\Exception\ImageCommitNotFoundException
     * @throws \Docker\OpenAPI\Exception\ImageCommitInternalServerErrorException
     *
     * @return \Docker\OpenAPI\Model\IdResponse|\Psr\Http\Message\ResponseInterface|null
     */
    public function imageCommit(\Docker\OpenAPI\Model\ContainerConfig $containerConfig, array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new \Docker\OpenAPI\Endpoint\ImageCommit($containerConfig, $queryParameters), $fetch);
    }

    /**
     * Stream real-time events from the server.

     *
     * @param array $queryParameters {
     *
     *     @var string $since show events created since this timestamp then stream new events
     *     @var string $until show events created until this timestamp then stop streaming
     *     @var string $filters A JSON encoded value of filters (a `map[string][]string`) to process on the event list. Available filters:

     * }
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\OpenAPI\Exception\SystemEventsBadRequestException
     * @throws \Docker\OpenAPI\Exception\SystemEventsInternalServerErrorException
     *
     * @return \Docker\OpenAPI\Model\EventsGetResponse200|\Psr\Http\Message\ResponseInterface|null
     */
    public function systemEvents(array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new \Docker\OpenAPI\Endpoint\SystemEvents($queryParameters), $fetch);
    }

    /**
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\OpenAPI\Exception\SystemDataUsageInternalServerErrorException
     *
     * @return \Docker\OpenAPI\Model\SystemDfGetResponse200|\Psr\Http\Message\ResponseInterface|null
     */
    public function systemDataUsage(string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new \Docker\OpenAPI\Endpoint\SystemDataUsage(), $fetch);
    }

    /**
     * Get a tarball containing all images and metadata for a repository.

     *
     * @param string $name  Image name or ID
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\OpenAPI\Exception\ImageGetInternalServerErrorException
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function imageGet(string $name, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new \Docker\OpenAPI\Endpoint\ImageGet($name), $fetch);
    }

    /**
     * Get a tarball containing all images and metadata for several image.
     *
     * @param array $queryParameters {
     *
     *     @var array $names Image names to filter by
     * }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\OpenAPI\Exception\ImageGetAllInternalServerErrorException
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function imageGetAll(array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new \Docker\OpenAPI\Endpoint\ImageGetAll($queryParameters), $fetch);
    }

    /**
     * Load a set of images and tags into a repository.

     *
     * @param string|resource|\Psr\Http\Message\StreamInterface $imagesTarball   Tar archive containing images
     * @param array                                             $queryParameters {
     *
     *     @var bool $quiet Suppress progress details during load.
     * }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\OpenAPI\Exception\ImageLoadInternalServerErrorException
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function imageLoad($imagesTarball, array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new \Docker\OpenAPI\Endpoint\ImageLoad($imagesTarball, $queryParameters), $fetch);
    }

    /**
     * Run a command inside a running container.
     *
     * @param string                                         $id         ID or name of container
     * @param \Docker\OpenAPI\Model\ContainersIdExecPostBody $execConfig Exec configuration
     * @param string                                         $fetch      Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\OpenAPI\Exception\ContainerExecNotFoundException
     * @throws \Docker\OpenAPI\Exception\ContainerExecConflictException
     * @throws \Docker\OpenAPI\Exception\ContainerExecInternalServerErrorException
     *
     * @return \Docker\OpenAPI\Model\IdResponse|\Psr\Http\Message\ResponseInterface|null
     */
    public function containerExec(string $id, \Docker\OpenAPI\Model\ContainersIdExecPostBody $execConfig, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new \Docker\OpenAPI\Endpoint\ContainerExec($id, $execConfig), $fetch);
    }

    /**
     * Starts a previously set up exec instance. If detach is true, this endpoint.
     *
     * @param string $id    Exec instance ID
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\OpenAPI\Exception\ExecStartNotFoundException
     * @throws \Docker\OpenAPI\Exception\ExecStartConflictException
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function execStart(string $id, \Docker\OpenAPI\Model\ExecIdStartPostBody $execStartConfig, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new \Docker\OpenAPI\Endpoint\ExecStart($id, $execStartConfig), $fetch);
    }

    /**
     * Resize the TTY session used by an exec instance. This endpoint only works.
     *
     * @param string $id              Exec instance ID
     * @param array  $queryParameters {
     *
     *     @var int $h Height of the TTY session in characters
     *     @var int $w Width of the TTY session in characters
     * }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\OpenAPI\Exception\ExecResizeNotFoundException
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function execResize(string $id, array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new \Docker\OpenAPI\Endpoint\ExecResize($id, $queryParameters), $fetch);
    }

    /**
     * Return low-level information about an exec instance.
     *
     * @param string $id    Exec instance ID
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\OpenAPI\Exception\ExecInspectNotFoundException
     * @throws \Docker\OpenAPI\Exception\ExecInspectInternalServerErrorException
     *
     * @return \Docker\OpenAPI\Model\ExecIdJsonGetResponse200|\Psr\Http\Message\ResponseInterface|null
     */
    public function execInspect(string $id, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new \Docker\OpenAPI\Endpoint\ExecInspect($id), $fetch);
    }

    /**
     * @param array $queryParameters {
     *
     *     @var string $filters JSON encoded value of the filters (a `map[string][]string`) to
     * }
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\OpenAPI\Exception\VolumeListInternalServerErrorException
     *
     * @return \Docker\OpenAPI\Model\VolumesGetResponse200|\Psr\Http\Message\ResponseInterface|null
     */
    public function volumeList(array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new \Docker\OpenAPI\Endpoint\VolumeList($queryParameters), $fetch);
    }

    /**
     * @param \Docker\OpenAPI\Model\VolumesCreatePostBody $volumeConfig Volume configuration
     * @param string                                      $fetch        Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\OpenAPI\Exception\VolumeCreateInternalServerErrorException
     *
     * @return \Docker\OpenAPI\Model\Volume|\Psr\Http\Message\ResponseInterface|null
     */
    public function volumeCreate(\Docker\OpenAPI\Model\VolumesCreatePostBody $volumeConfig, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new \Docker\OpenAPI\Endpoint\VolumeCreate($volumeConfig), $fetch);
    }

    /**
     * Instruct the driver to remove the volume.
     *
     * @param string $name            Volume name or ID
     * @param array  $queryParameters {
     *
     *     @var bool $force Force the removal of the volume
     * }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\OpenAPI\Exception\VolumeDeleteNotFoundException
     * @throws \Docker\OpenAPI\Exception\VolumeDeleteConflictException
     * @throws \Docker\OpenAPI\Exception\VolumeDeleteInternalServerErrorException
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function volumeDelete(string $name, array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new \Docker\OpenAPI\Endpoint\VolumeDelete($name, $queryParameters), $fetch);
    }

    /**
     * @param string $name  Volume name or ID
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\OpenAPI\Exception\VolumeInspectNotFoundException
     * @throws \Docker\OpenAPI\Exception\VolumeInspectInternalServerErrorException
     *
     * @return \Docker\OpenAPI\Model\Volume|\Psr\Http\Message\ResponseInterface|null
     */
    public function volumeInspect(string $name, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new \Docker\OpenAPI\Endpoint\VolumeInspect($name), $fetch);
    }

    /**
     * @param array $queryParameters {
     *
     *     @var string $filters Filters to process on the prune list, encoded as JSON (a `map[string][]string`).

     * }
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\OpenAPI\Exception\VolumePruneInternalServerErrorException
     *
     * @return \Docker\OpenAPI\Model\VolumesPrunePostResponse200|\Psr\Http\Message\ResponseInterface|null
     */
    public function volumePrune(array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new \Docker\OpenAPI\Endpoint\VolumePrune($queryParameters), $fetch);
    }

    /**
     * Returns a list of networks. For details on the format, see the.
     *
     * @param array $queryParameters {
     *
     *     @var string $filters JSON encoded value of the filters (a `map[string][]string`) to process
     * }
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\OpenAPI\Exception\NetworkListInternalServerErrorException
     *
     * @return \Docker\OpenAPI\Model\Network[]|\Psr\Http\Message\ResponseInterface|null
     */
    public function networkList(array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new \Docker\OpenAPI\Endpoint\NetworkList($queryParameters), $fetch);
    }

    /**
     * @param string $id    Network ID or name
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\OpenAPI\Exception\NetworkDeleteForbiddenException
     * @throws \Docker\OpenAPI\Exception\NetworkDeleteNotFoundException
     * @throws \Docker\OpenAPI\Exception\NetworkDeleteInternalServerErrorException
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function networkDelete(string $id, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new \Docker\OpenAPI\Endpoint\NetworkDelete($id), $fetch);
    }

    /**
     * @param string $id              Network ID or name
     * @param array  $queryParameters {
     *
     *     @var bool $verbose Detailed inspect output for troubleshooting
     *     @var string $scope Filter the network by scope (swarm, global, or local)
     * }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\OpenAPI\Exception\NetworkInspectNotFoundException
     * @throws \Docker\OpenAPI\Exception\NetworkInspectInternalServerErrorException
     *
     * @return \Docker\OpenAPI\Model\Network|\Psr\Http\Message\ResponseInterface|null
     */
    public function networkInspect(string $id, array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new \Docker\OpenAPI\Endpoint\NetworkInspect($id, $queryParameters), $fetch);
    }

    /**
     * @param \Docker\OpenAPI\Model\NetworksCreatePostBody $networkConfig Network configuration
     * @param string                                       $fetch         Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\OpenAPI\Exception\NetworkCreateForbiddenException
     * @throws \Docker\OpenAPI\Exception\NetworkCreateNotFoundException
     * @throws \Docker\OpenAPI\Exception\NetworkCreateInternalServerErrorException
     *
     * @return \Docker\OpenAPI\Model\NetworksCreatePostResponse201|\Psr\Http\Message\ResponseInterface|null
     */
    public function networkCreate(\Docker\OpenAPI\Model\NetworksCreatePostBody $networkConfig, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new \Docker\OpenAPI\Endpoint\NetworkCreate($networkConfig), $fetch);
    }

    /**
     * @param string $id    Network ID or name
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\OpenAPI\Exception\NetworkConnectForbiddenException
     * @throws \Docker\OpenAPI\Exception\NetworkConnectNotFoundException
     * @throws \Docker\OpenAPI\Exception\NetworkConnectInternalServerErrorException
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function networkConnect(string $id, \Docker\OpenAPI\Model\NetworksIdConnectPostBody $container, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new \Docker\OpenAPI\Endpoint\NetworkConnect($id, $container), $fetch);
    }

    /**
     * @param string $id    Network ID or name
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\OpenAPI\Exception\NetworkDisconnectForbiddenException
     * @throws \Docker\OpenAPI\Exception\NetworkDisconnectNotFoundException
     * @throws \Docker\OpenAPI\Exception\NetworkDisconnectInternalServerErrorException
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function networkDisconnect(string $id, \Docker\OpenAPI\Model\NetworksIdDisconnectPostBody $container, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new \Docker\OpenAPI\Endpoint\NetworkDisconnect($id, $container), $fetch);
    }

    /**
     * @param array $queryParameters {
     *
     *     @var string $filters Filters to process on the prune list, encoded as JSON (a `map[string][]string`).

     * }
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\OpenAPI\Exception\NetworkPruneInternalServerErrorException
     *
     * @return \Docker\OpenAPI\Model\NetworksPrunePostResponse200|\Psr\Http\Message\ResponseInterface|null
     */
    public function networkPrune(array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new \Docker\OpenAPI\Endpoint\NetworkPrune($queryParameters), $fetch);
    }

    /**
     * Returns information about installed plugins.
     *
     * @param array $queryParameters {
     *
     *     @var string $filters A JSON encoded value of the filters (a `map[string][]string`) to
     * }
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\OpenAPI\Exception\PluginListInternalServerErrorException
     *
     * @return \Docker\OpenAPI\Model\Plugin[]|\Psr\Http\Message\ResponseInterface|null
     */
    public function pluginList(array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new \Docker\OpenAPI\Endpoint\PluginList($queryParameters), $fetch);
    }

    /**
     * @param array $queryParameters {
     *
     *     @var string $remote The name of the plugin. The `:latest` tag is optional, and is the
    default if omitted.

     * }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\OpenAPI\Exception\GetPluginPrivilegesInternalServerErrorException
     *
     * @return \Docker\OpenAPI\Model\PluginsPrivilegesGetResponse200Item[]|\Psr\Http\Message\ResponseInterface|null
     */
    public function getPluginPrivileges(array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new \Docker\OpenAPI\Endpoint\GetPluginPrivileges($queryParameters), $fetch);
    }

    /**
     * Pulls and installs a plugin. After the plugin is installed, it can be.
     *
     * @param array $queryParameters {
     *
     *     @var string $remote Remote reference for plugin to install.

     *     @var string $name Local name for the pulled plugin.

    The `:latest` tag is optional, and is used as the default if omitted.

     * }
     *
     * @param array $headerParameters {
     *
     *     @var string $X-Registry-Auth A base64url-encoded auth configuration to use when pulling a plugin
     * }
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\OpenAPI\Exception\PluginPullInternalServerErrorException
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function pluginPull(array $body, array $queryParameters = [], array $headerParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new \Docker\OpenAPI\Endpoint\PluginPull($body, $queryParameters, $headerParameters), $fetch);
    }

    /**
     * @param string $name  The name of the plugin. The `:latest` tag is optional, and is the
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\OpenAPI\Exception\PluginInspectNotFoundException
     * @throws \Docker\OpenAPI\Exception\PluginInspectInternalServerErrorException
     *
     * @return \Docker\OpenAPI\Model\Plugin|\Psr\Http\Message\ResponseInterface|null
     */
    public function pluginInspect(string $name, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new \Docker\OpenAPI\Endpoint\PluginInspect($name), $fetch);
    }

    /**
     * @param string $name            The name of the plugin. The `:latest` tag is optional, and is the
     * @param array  $queryParameters {
     *
     *     @var bool $force Disable the plugin before removing. This may result in issues if the
    plugin is in use by a container.

     * }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\OpenAPI\Exception\PluginDeleteNotFoundException
     * @throws \Docker\OpenAPI\Exception\PluginDeleteInternalServerErrorException
     *
     * @return \Docker\OpenAPI\Model\Plugin|\Psr\Http\Message\ResponseInterface|null
     */
    public function pluginDelete(string $name, array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new \Docker\OpenAPI\Endpoint\PluginDelete($name, $queryParameters), $fetch);
    }

    /**
     * @param string $name            The name of the plugin. The `:latest` tag is optional, and is the
     * @param array  $queryParameters {
     *
     *     @var int $timeout Set the HTTP client timeout (in seconds)
     * }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\OpenAPI\Exception\PluginEnableNotFoundException
     * @throws \Docker\OpenAPI\Exception\PluginEnableInternalServerErrorException
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function pluginEnable(string $name, array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new \Docker\OpenAPI\Endpoint\PluginEnable($name, $queryParameters), $fetch);
    }

    /**
     * @param string $name  The name of the plugin. The `:latest` tag is optional, and is the
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\OpenAPI\Exception\PluginDisableNotFoundException
     * @throws \Docker\OpenAPI\Exception\PluginDisableInternalServerErrorException
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function pluginDisable(string $name, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new \Docker\OpenAPI\Endpoint\PluginDisable($name), $fetch);
    }

    /**
     * @param string $name            The name of the plugin. The `:latest` tag is optional, and is the
     * @param array  $queryParameters {
     *
     *     @var string $remote Remote reference to upgrade to.

    The `:latest` tag is optional, and is used as the default if omitted.

     * }
     *
     * @param array $headerParameters {
     *
     *     @var string $X-Registry-Auth A base64url-encoded auth configuration to use when pulling a plugin
     * }
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\OpenAPI\Exception\PluginUpgradeNotFoundException
     * @throws \Docker\OpenAPI\Exception\PluginUpgradeInternalServerErrorException
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function pluginUpgrade(string $name, array $body, array $queryParameters = [], array $headerParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new \Docker\OpenAPI\Endpoint\PluginUpgrade($name, $body, $queryParameters, $headerParameters), $fetch);
    }

    /**
     * @param string|resource|\Psr\Http\Message\StreamInterface $tarContext      Path to tar containing plugin rootfs and manifest
     * @param array                                             $queryParameters {
     *
     *     @var string $name The name of the plugin. The `:latest` tag is optional, and is the
    default if omitted.

     * }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\OpenAPI\Exception\PluginCreateInternalServerErrorException
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function pluginCreate($tarContext, array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new \Docker\OpenAPI\Endpoint\PluginCreate($tarContext, $queryParameters), $fetch);
    }

    /**
     * Push a plugin to the registry.

     *
     * @param string $name  The name of the plugin. The `:latest` tag is optional, and is the
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\OpenAPI\Exception\PluginPushNotFoundException
     * @throws \Docker\OpenAPI\Exception\PluginPushInternalServerErrorException
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function pluginPush(string $name, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new \Docker\OpenAPI\Endpoint\PluginPush($name), $fetch);
    }

    /**
     * @param string $name  The name of the plugin. The `:latest` tag is optional, and is the
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\OpenAPI\Exception\PluginSetNotFoundException
     * @throws \Docker\OpenAPI\Exception\PluginSetInternalServerErrorException
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function pluginSet(string $name, array $body, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new \Docker\OpenAPI\Endpoint\PluginSet($name, $body), $fetch);
    }

    /**
     * @param array $queryParameters {
     *
     *     @var string $filters Filters to process on the nodes list, encoded as JSON (a `map[string][]string`).

     * }
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\OpenAPI\Exception\NodeListInternalServerErrorException
     * @throws \Docker\OpenAPI\Exception\NodeListServiceUnavailableException
     *
     * @return \Docker\OpenAPI\Model\Node[]|\Psr\Http\Message\ResponseInterface|null
     */
    public function nodeList(array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new \Docker\OpenAPI\Endpoint\NodeList($queryParameters), $fetch);
    }

    /**
     * @param string $id              The ID or name of the node
     * @param array  $queryParameters {
     *
     *     @var bool $force Force remove a node from the swarm
     * }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\OpenAPI\Exception\NodeDeleteNotFoundException
     * @throws \Docker\OpenAPI\Exception\NodeDeleteInternalServerErrorException
     * @throws \Docker\OpenAPI\Exception\NodeDeleteServiceUnavailableException
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function nodeDelete(string $id, array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new \Docker\OpenAPI\Endpoint\NodeDelete($id, $queryParameters), $fetch);
    }

    /**
     * @param string $id    The ID or name of the node
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\OpenAPI\Exception\NodeInspectNotFoundException
     * @throws \Docker\OpenAPI\Exception\NodeInspectInternalServerErrorException
     * @throws \Docker\OpenAPI\Exception\NodeInspectServiceUnavailableException
     *
     * @return \Docker\OpenAPI\Model\Node|\Psr\Http\Message\ResponseInterface|null
     */
    public function nodeInspect(string $id, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new \Docker\OpenAPI\Endpoint\NodeInspect($id), $fetch);
    }

    /**
     * @param string $id              The ID of the node
     * @param array  $queryParameters {
     *
     *     @var int $version The version number of the node object being updated. This is required
    to avoid conflicting writes.

     * }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\OpenAPI\Exception\NodeUpdateBadRequestException
     * @throws \Docker\OpenAPI\Exception\NodeUpdateNotFoundException
     * @throws \Docker\OpenAPI\Exception\NodeUpdateInternalServerErrorException
     * @throws \Docker\OpenAPI\Exception\NodeUpdateServiceUnavailableException
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function nodeUpdate(string $id, \Docker\OpenAPI\Model\NodeSpec $body, array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new \Docker\OpenAPI\Endpoint\NodeUpdate($id, $body, $queryParameters), $fetch);
    }

    /**
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\OpenAPI\Exception\SwarmInspectNotFoundException
     * @throws \Docker\OpenAPI\Exception\SwarmInspectInternalServerErrorException
     * @throws \Docker\OpenAPI\Exception\SwarmInspectServiceUnavailableException
     *
     * @return \Docker\OpenAPI\Model\Swarm|\Psr\Http\Message\ResponseInterface|null
     */
    public function swarmInspect(string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new \Docker\OpenAPI\Endpoint\SwarmInspect(), $fetch);
    }

    /**
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\OpenAPI\Exception\SwarmInitBadRequestException
     * @throws \Docker\OpenAPI\Exception\SwarmInitInternalServerErrorException
     * @throws \Docker\OpenAPI\Exception\SwarmInitServiceUnavailableException
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function swarmInit(\Docker\OpenAPI\Model\SwarmInitPostBody $body, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new \Docker\OpenAPI\Endpoint\SwarmInit($body), $fetch);
    }

    /**
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\OpenAPI\Exception\SwarmJoinBadRequestException
     * @throws \Docker\OpenAPI\Exception\SwarmJoinInternalServerErrorException
     * @throws \Docker\OpenAPI\Exception\SwarmJoinServiceUnavailableException
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function swarmJoin(\Docker\OpenAPI\Model\SwarmJoinPostBody $body, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new \Docker\OpenAPI\Endpoint\SwarmJoin($body), $fetch);
    }

    /**
     * @param array $queryParameters {
     *
     *     @var bool $force Force leave swarm, even if this is the last manager or that it will
    break the cluster.

     * }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\OpenAPI\Exception\SwarmLeaveInternalServerErrorException
     * @throws \Docker\OpenAPI\Exception\SwarmLeaveServiceUnavailableException
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function swarmLeave(array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new \Docker\OpenAPI\Endpoint\SwarmLeave($queryParameters), $fetch);
    }

    /**
     * @param array $queryParameters {
     *
     *     @var int $version The version number of the swarm object being updated. This is
     *     @var bool $rotateWorkerToken rotate the worker join token
     *     @var bool $rotateManagerToken rotate the manager join token
     *     @var bool $rotateManagerUnlockKey Rotate the manager unlock key.
     * }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\OpenAPI\Exception\SwarmUpdateBadRequestException
     * @throws \Docker\OpenAPI\Exception\SwarmUpdateInternalServerErrorException
     * @throws \Docker\OpenAPI\Exception\SwarmUpdateServiceUnavailableException
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function swarmUpdate(\Docker\OpenAPI\Model\SwarmSpec $body, array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new \Docker\OpenAPI\Endpoint\SwarmUpdate($body, $queryParameters), $fetch);
    }

    /**
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\OpenAPI\Exception\SwarmUnlockkeyInternalServerErrorException
     * @throws \Docker\OpenAPI\Exception\SwarmUnlockkeyServiceUnavailableException
     *
     * @return \Docker\OpenAPI\Model\SwarmUnlockkeyGetResponse200|\Psr\Http\Message\ResponseInterface|null
     */
    public function swarmUnlockkey(string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new \Docker\OpenAPI\Endpoint\SwarmUnlockkey(), $fetch);
    }

    /**
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\OpenAPI\Exception\SwarmUnlockInternalServerErrorException
     * @throws \Docker\OpenAPI\Exception\SwarmUnlockServiceUnavailableException
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function swarmUnlock(\Docker\OpenAPI\Model\SwarmUnlockPostBody $body, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new \Docker\OpenAPI\Endpoint\SwarmUnlock($body), $fetch);
    }

    /**
     * @param array $queryParameters {
     *
     *     @var string $filters A JSON encoded value of the filters (a `map[string][]string`) to
     * }
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\OpenAPI\Exception\ServiceListInternalServerErrorException
     * @throws \Docker\OpenAPI\Exception\ServiceListServiceUnavailableException
     *
     * @return \Docker\OpenAPI\Model\Service[]|\Psr\Http\Message\ResponseInterface|null
     */
    public function serviceList(array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new \Docker\OpenAPI\Endpoint\ServiceList($queryParameters), $fetch);
    }

    /**
     * @param array $headerParameters {
     *
     *     @var string $X-Registry-Auth A base64url-encoded auth configuration for pulling from private
     * }
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\OpenAPI\Exception\ServiceCreateBadRequestException
     * @throws \Docker\OpenAPI\Exception\ServiceCreateForbiddenException
     * @throws \Docker\OpenAPI\Exception\ServiceCreateConflictException
     * @throws \Docker\OpenAPI\Exception\ServiceCreateInternalServerErrorException
     * @throws \Docker\OpenAPI\Exception\ServiceCreateServiceUnavailableException
     *
     * @return \Docker\OpenAPI\Model\ServicesCreatePostResponse201|\Psr\Http\Message\ResponseInterface|null
     */
    public function serviceCreate(\Docker\OpenAPI\Model\ServicesCreatePostBody $body, array $headerParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new \Docker\OpenAPI\Endpoint\ServiceCreate($body, $headerParameters), $fetch);
    }

    /**
     * @param string $id    ID or name of service
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\OpenAPI\Exception\ServiceDeleteNotFoundException
     * @throws \Docker\OpenAPI\Exception\ServiceDeleteInternalServerErrorException
     * @throws \Docker\OpenAPI\Exception\ServiceDeleteServiceUnavailableException
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function serviceDelete(string $id, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new \Docker\OpenAPI\Endpoint\ServiceDelete($id), $fetch);
    }

    /**
     * @param string $id              ID or name of service
     * @param array  $queryParameters {
     *
     *     @var bool $insertDefaults Fill empty fields with default values.
     * }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\OpenAPI\Exception\ServiceInspectNotFoundException
     * @throws \Docker\OpenAPI\Exception\ServiceInspectInternalServerErrorException
     * @throws \Docker\OpenAPI\Exception\ServiceInspectServiceUnavailableException
     *
     * @return \Docker\OpenAPI\Model\Service|\Psr\Http\Message\ResponseInterface|null
     */
    public function serviceInspect(string $id, array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new \Docker\OpenAPI\Endpoint\ServiceInspect($id, $queryParameters), $fetch);
    }

    /**
     * @param string $id              ID or name of service
     * @param array  $queryParameters {
     *
     *     @var int $version The version number of the service object being updated. This is
     *     @var string $registryAuthFrom If the `X-Registry-Auth` header is not specified, this parameter
     *     @var string $rollback Set to this parameter to `previous` to cause a server-side rollback
     * }
     * @param array $headerParameters {
     *
     *     @var string $X-Registry-Auth A base64url-encoded auth configuration for pulling from private
     * }
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\OpenAPI\Exception\ServiceUpdateBadRequestException
     * @throws \Docker\OpenAPI\Exception\ServiceUpdateNotFoundException
     * @throws \Docker\OpenAPI\Exception\ServiceUpdateInternalServerErrorException
     * @throws \Docker\OpenAPI\Exception\ServiceUpdateServiceUnavailableException
     *
     * @return \Docker\OpenAPI\Model\ServiceUpdateResponse|\Psr\Http\Message\ResponseInterface|null
     */
    public function serviceUpdate(string $id, \Docker\OpenAPI\Model\ServicesIdUpdatePostBody $body, array $queryParameters = [], array $headerParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new \Docker\OpenAPI\Endpoint\ServiceUpdate($id, $body, $queryParameters, $headerParameters), $fetch);
    }

    /**
     * Get `stdout` and `stderr` logs from a service. See also.
    [`/containers/{id}/logs`](#operation/ContainerLogs).

     **Note**: This endpoint works only for services with the `local`,
     *
     * @param string $id              ID or name of the service
     * @param array  $queryParameters {
     *
     *     @var bool $details show service context and extra details provided to logs
     *     @var bool $follow keep connection after returning logs
     *     @var bool $stdout Return logs from `stdout`
     *     @var bool $stderr Return logs from `stderr`
     *     @var int $since Only return logs since this time, as a UNIX timestamp
     *     @var bool $timestamps Add timestamps to every log line
     *     @var string $tail Only return this number of log lines from the end of the logs.
    Specify as an integer or `all` to output all log lines.

     * }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\OpenAPI\Exception\ServiceLogsNotFoundException
     * @throws \Docker\OpenAPI\Exception\ServiceLogsInternalServerErrorException
     * @throws \Docker\OpenAPI\Exception\ServiceLogsServiceUnavailableException
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function serviceLogs(string $id, array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new \Docker\OpenAPI\Endpoint\ServiceLogs($id, $queryParameters), $fetch);
    }

    /**
     * @param array $queryParameters {
     *
     *     @var string $filters A JSON encoded value of the filters (a `map[string][]string`) to
     * }
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\OpenAPI\Exception\TaskListInternalServerErrorException
     * @throws \Docker\OpenAPI\Exception\TaskListServiceUnavailableException
     *
     * @return \Docker\OpenAPI\Model\Task[]|\Psr\Http\Message\ResponseInterface|null
     */
    public function taskList(array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new \Docker\OpenAPI\Endpoint\TaskList($queryParameters), $fetch);
    }

    /**
     * @param string $id    ID of the task
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\OpenAPI\Exception\TaskInspectNotFoundException
     * @throws \Docker\OpenAPI\Exception\TaskInspectInternalServerErrorException
     * @throws \Docker\OpenAPI\Exception\TaskInspectServiceUnavailableException
     *
     * @return \Docker\OpenAPI\Model\Task|\Psr\Http\Message\ResponseInterface|null
     */
    public function taskInspect(string $id, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new \Docker\OpenAPI\Endpoint\TaskInspect($id), $fetch);
    }

    /**
     * Get `stdout` and `stderr` logs from a task.
    See also [`/containers/{id}/logs`](#operation/ContainerLogs).

     **Note**: This endpoint works only for services with the `local`,
     *
     * @param string $id              ID of the task
     * @param array  $queryParameters {
     *
     *     @var bool $details show task context and extra details provided to logs
     *     @var bool $follow keep connection after returning logs
     *     @var bool $stdout Return logs from `stdout`
     *     @var bool $stderr Return logs from `stderr`
     *     @var int $since Only return logs since this time, as a UNIX timestamp
     *     @var bool $timestamps Add timestamps to every log line
     *     @var string $tail Only return this number of log lines from the end of the logs.
    Specify as an integer or `all` to output all log lines.

     * }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\OpenAPI\Exception\TaskLogsNotFoundException
     * @throws \Docker\OpenAPI\Exception\TaskLogsInternalServerErrorException
     * @throws \Docker\OpenAPI\Exception\TaskLogsServiceUnavailableException
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function taskLogs(string $id, array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new \Docker\OpenAPI\Endpoint\TaskLogs($id, $queryParameters), $fetch);
    }

    /**
     * @param array $queryParameters {
     *
     *     @var string $filters A JSON encoded value of the filters (a `map[string][]string`) to
     * }
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\OpenAPI\Exception\SecretListInternalServerErrorException
     * @throws \Docker\OpenAPI\Exception\SecretListServiceUnavailableException
     *
     * @return \Docker\OpenAPI\Model\Secret[]|\Psr\Http\Message\ResponseInterface|null
     */
    public function secretList(array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new \Docker\OpenAPI\Endpoint\SecretList($queryParameters), $fetch);
    }

    /**
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\OpenAPI\Exception\SecretCreateConflictException
     * @throws \Docker\OpenAPI\Exception\SecretCreateInternalServerErrorException
     * @throws \Docker\OpenAPI\Exception\SecretCreateServiceUnavailableException
     *
     * @return \Docker\OpenAPI\Model\IdResponse|\Psr\Http\Message\ResponseInterface|null
     */
    public function secretCreate(\Docker\OpenAPI\Model\SecretsCreatePostBody $body, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new \Docker\OpenAPI\Endpoint\SecretCreate($body), $fetch);
    }

    /**
     * @param string $id    ID of the secret
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\OpenAPI\Exception\SecretDeleteNotFoundException
     * @throws \Docker\OpenAPI\Exception\SecretDeleteInternalServerErrorException
     * @throws \Docker\OpenAPI\Exception\SecretDeleteServiceUnavailableException
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function secretDelete(string $id, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new \Docker\OpenAPI\Endpoint\SecretDelete($id), $fetch);
    }

    /**
     * @param string $id    ID of the secret
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\OpenAPI\Exception\SecretInspectNotFoundException
     * @throws \Docker\OpenAPI\Exception\SecretInspectInternalServerErrorException
     * @throws \Docker\OpenAPI\Exception\SecretInspectServiceUnavailableException
     *
     * @return \Docker\OpenAPI\Model\Secret|\Psr\Http\Message\ResponseInterface|null
     */
    public function secretInspect(string $id, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new \Docker\OpenAPI\Endpoint\SecretInspect($id), $fetch);
    }

    /**
     * @param string                           $id              The ID or name of the secret
     * @param \Docker\OpenAPI\Model\SecretSpec $body            The spec of the secret to update. Currently, only the Labels field
     * @param array                            $queryParameters {
     *
     *     @var int $version The version number of the secret object being updated. This is
    required to avoid conflicting writes.

     * }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\OpenAPI\Exception\SecretUpdateBadRequestException
     * @throws \Docker\OpenAPI\Exception\SecretUpdateNotFoundException
     * @throws \Docker\OpenAPI\Exception\SecretUpdateInternalServerErrorException
     * @throws \Docker\OpenAPI\Exception\SecretUpdateServiceUnavailableException
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function secretUpdate(string $id, \Docker\OpenAPI\Model\SecretSpec $body, array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new \Docker\OpenAPI\Endpoint\SecretUpdate($id, $body, $queryParameters), $fetch);
    }

    /**
     * @param array $queryParameters {
     *
     *     @var string $filters A JSON encoded value of the filters (a `map[string][]string`) to
     * }
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\OpenAPI\Exception\ConfigListInternalServerErrorException
     * @throws \Docker\OpenAPI\Exception\ConfigListServiceUnavailableException
     *
     * @return \Docker\OpenAPI\Model\Config[]|\Psr\Http\Message\ResponseInterface|null
     */
    public function configList(array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new \Docker\OpenAPI\Endpoint\ConfigList($queryParameters), $fetch);
    }

    /**
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\OpenAPI\Exception\ConfigCreateConflictException
     * @throws \Docker\OpenAPI\Exception\ConfigCreateInternalServerErrorException
     * @throws \Docker\OpenAPI\Exception\ConfigCreateServiceUnavailableException
     *
     * @return \Docker\OpenAPI\Model\IdResponse|\Psr\Http\Message\ResponseInterface|null
     */
    public function configCreate(\Docker\OpenAPI\Model\ConfigsCreatePostBody $body, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new \Docker\OpenAPI\Endpoint\ConfigCreate($body), $fetch);
    }

    /**
     * @param string $id    ID of the config
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\OpenAPI\Exception\ConfigDeleteNotFoundException
     * @throws \Docker\OpenAPI\Exception\ConfigDeleteInternalServerErrorException
     * @throws \Docker\OpenAPI\Exception\ConfigDeleteServiceUnavailableException
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function configDelete(string $id, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new \Docker\OpenAPI\Endpoint\ConfigDelete($id), $fetch);
    }

    /**
     * @param string $id    ID of the config
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\OpenAPI\Exception\ConfigInspectNotFoundException
     * @throws \Docker\OpenAPI\Exception\ConfigInspectInternalServerErrorException
     * @throws \Docker\OpenAPI\Exception\ConfigInspectServiceUnavailableException
     *
     * @return \Docker\OpenAPI\Model\Config|\Psr\Http\Message\ResponseInterface|null
     */
    public function configInspect(string $id, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new \Docker\OpenAPI\Endpoint\ConfigInspect($id), $fetch);
    }

    /**
     * @param string                           $id              The ID or name of the config
     * @param \Docker\OpenAPI\Model\ConfigSpec $body            The spec of the config to update. Currently, only the Labels field
     * @param array                            $queryParameters {
     *
     *     @var int $version The version number of the config object being updated. This is
    required to avoid conflicting writes.

     * }
     *
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\OpenAPI\Exception\ConfigUpdateBadRequestException
     * @throws \Docker\OpenAPI\Exception\ConfigUpdateNotFoundException
     * @throws \Docker\OpenAPI\Exception\ConfigUpdateInternalServerErrorException
     * @throws \Docker\OpenAPI\Exception\ConfigUpdateServiceUnavailableException
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function configUpdate(string $id, \Docker\OpenAPI\Model\ConfigSpec $body, array $queryParameters = [], string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new \Docker\OpenAPI\Endpoint\ConfigUpdate($id, $body, $queryParameters), $fetch);
    }

    /**
     * Return image digest and platform information by contacting the registry.
     *
     * @param string $name  Image name or id
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\OpenAPI\Exception\DistributionInspectUnauthorizedException
     * @throws \Docker\OpenAPI\Exception\DistributionInspectInternalServerErrorException
     *
     * @return \Docker\OpenAPI\Model\DistributionNameJsonGetResponse200|\Psr\Http\Message\ResponseInterface|null
     */
    public function distributionInspect(string $name, string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new \Docker\OpenAPI\Endpoint\DistributionInspect($name), $fetch);
    }

    /**
     * @param string $fetch Fetch mode to use (can be OBJECT or RESPONSE)
     *
     * @throws \Docker\OpenAPI\Exception\SessionBadRequestException
     * @throws \Docker\OpenAPI\Exception\SessionInternalServerErrorException
     *
     * @return \Psr\Http\Message\ResponseInterface|null
     */
    public function session(string $fetch = self::FETCH_OBJECT)
    {
        return $this->executeEndpoint(new \Docker\OpenAPI\Endpoint\Session(), $fetch);
    }

    public static function create($httpClient = null, array $additionalPlugins = [])
    {
        if (null === $httpClient) {
            $httpClient = \Http\Discovery\Psr18ClientDiscovery::find();
            $plugins = [];
            if (count($additionalPlugins) > 0) {
                $plugins = array_merge($plugins, $additionalPlugins);
            }
            $httpClient = new \Http\Client\Common\PluginClient($httpClient, $plugins);
        }
        $requestFactory = \Http\Discovery\Psr17FactoryDiscovery::findRequestFactory();
        $streamFactory = \Http\Discovery\Psr17FactoryDiscovery::findStreamFactory();
        $serializer = new \Symfony\Component\Serializer\Serializer([new \Symfony\Component\Serializer\Normalizer\ArrayDenormalizer(), new \Docker\OpenAPI\Normalizer\JaneObjectNormalizer()], [new \Symfony\Component\Serializer\Encoder\JsonEncoder(new \Symfony\Component\Serializer\Encoder\JsonEncode(), new \Symfony\Component\Serializer\Encoder\JsonDecode(['json_decode_associative' => true]))]);

        return new static($httpClient, $requestFactory, $serializer, $streamFactory);
    }
}
